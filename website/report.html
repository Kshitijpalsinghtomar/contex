<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contex Benchmark Dashboard</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Inter:wght@400;500;600;700&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="./style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const theme = localStorage.getItem('contex-theme') || 'dark';
        document.documentElement.setAttribute('data-theme', theme);
    </script>
</head>

<body>
    <!-- Navigation -->
    <nav class="nav">
        <a href="./" class="nav-brand">
            <div class="logo-icon">C</div>
            Contex
        </a>
        <ul class="nav-links">
            <li><a href="./">Home</a></li>
            <li><a href="./docs.html">Docs</a></li>
            <li><a href="./tens-text.html">TENS-Text</a></li>
            <li><a href="./benchmarks.html" class="active">Benchmarks</a></li>
            <li><a href="./playground.html">Playground</a></li>
            <li><a href="./vision.html">Vision</a></li>
            <li><a href="./dashboard.html">Dashboard</a></li>
        </ul>
        <div class="nav-actions">
            <button class="btn btn-ghost btn-sm" id="theme-toggle" aria-label="Toggle theme">
                <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
                <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
            </button>
            <a href="https://github.com/kshitijpalsinghtomar/contex-llm" class="btn btn-ghost btn-sm" target="_blank">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                    <path
                        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
                    </path>
                </svg>
                GitHub
            </a>
        </div>
    </nav>

    <div class="container">
        <div id="error-log"></div>

        <header>
            <div>
                <h1>Benchmark Report</h1>
                <div class="dim text-sm">Automated Performance Analysis &bull; Feb 2026</div>
            </div>
        </header>

        <div class="header-controls">
            <div style="display:flex; align-items:center; gap:12px;">
                <label class="dim" style="font-size: 13px; font-weight:500;">DATASET:</label>
                <select id="datasetSelect"></select>
            </div>
            <div style="width: 1px; height: 24px; background: var(--border-subtle); margin: 0 16px;"></div>
            <div class="dim" style="font-size:13px;">Reviewing <strong style="color:var(--text-primary)">1,000
                    records</strong> (std batch)</div>
        </div>

        <!-- Key Metrics -->
        <div class="grid">
            <div class="card">
                <div class="card-label">Token Savings</div>
                <div class="card-value number" id="kpiSavings">--</div>
                <div class="card-sub">vs JSON (1k rows)</div>
            </div>
            <div class="card">
                <div class="card-label">Context Density</div>
                <div class="card-value number" id="kpiDensity">--</div>
                <div class="card-sub trend-up">More data per window</div>
            </div>
            <div class="card">
                <div class="card-label">Cost Efficiency</div>
                <div class="card-value number" id="kpiRoi">--</div>
                <div class="card-sub">Est. ROI (GPT-4o)</div>
            </div>
            <div class="card">
                <div class="card-label">Encoding Speed</div>
                <div class="card-value number" id="kpiSpeed">--</div>
                <div class="card-sub">Ops/Sec (Global)</div>
            </div>
        </div>

        <!-- Charts -->
        <div class="grid">
            <div class="card col-2">
                <h2><span style="color:var(--accent-blue)">■</span> Cost Projection ($/Year)</h2>
                <div class="chart-wrap"><canvas id="chartCost"></canvas></div>
            </div>
            <div class="card col-2">
                <h2><span style="color:var(--accent-purple)">■</span> Token Growth Scaling</h2>
                <div class="chart-wrap"><canvas id="chartScaling"></canvas></div>
            </div>
            <div class="card col-4">
                <h2><span style="color:var(--accent-green)">■</span> Latency vs Input Size (ms)</h2>
                <div class="chart-wrap"><canvas id="chartLatency"></canvas></div>
            </div>
        </div>

        <!-- Comparison Tool -->
        <div class="comparison-tool" id="comparisonTool">
            <h2>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M9 21H4v-5" />
                </svg>
                Direct Comparison
            </h2>
            <div style="margin-top:16px; display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
                <select id="compA">
                    <option value="json">JSON</option>
                </select>
                <span class="dim">vs</span>
                <select id="compB">
                    <option value="contex" selected>Contex Compact</option>
                </select>
            </div>

            <div class="comp-stats">
                <div class="stat-box">
                    <div>Tokens</div>
                    <div id="diffTokens" style="color:var(--accent-green)">-59%</div>
                </div>
                <div class="stat-box">
                    <div>Size</div>
                    <div id="diffSize" style="color:var(--accent-purple)">-76%</div>
                </div>
                <div class="stat-box">
                    <div>Cost/Avg</div>
                    <div id="diffCost" style="color:var(--accent-green)">-59%</div>
                </div>
                <div class="stat-box">
                    <div>Density</div>
                    <div id="diffDensity" style="color:var(--text-primary)">2.4x</div>
                </div>
            </div>
        </div>

        <div style="height:48px;"></div>

        <!-- Data Table -->
        <div class="card col-4">
            <h2>Detailed Matrix (<span id="tableName">RealWorld</span>)</h2>
            <div style="overflow-x:auto">
                <table id="matrixTable">
                    <thead>
                        <tr>
                            <th>Format</th>
                            <th>Rows</th>
                            <th>Tokens</th>
                            <th>Size (KB)</th>
                            <th>Overhead</th>
                            <th>Est. Cost ($/1M)</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

    </div>

    <script>
        let DATA = null;
        let costChart = null;
        let scalingChart = null;
        let latencyChart = null;
        let compA = null;
        let compB = null;

        const MODELS = {
            "gpt-4o": { "name": "GPT-4o", "inputPricePer1M": 2.5, "contextWindow": 128000 },
            "claude-3-5-sonnet": { "name": "Claude 3.5 Sonnet", "inputPricePer1M": 3, "contextWindow": 200000 }
        };
        const INPUT_PRICE = 2.50;

        async function loadData() {
            try {
                const response = await fetch('benchmark_results.json');
                const raw = await response.json();
                // Support both flat array and { matrix: [...] } formats
                DATA = { matrix: Array.isArray(raw) ? raw : (raw.matrix || []) };
                initDashboard();
            } catch (e) {
                console.error("Failed to load data:", e);
                document.getElementById('error-log').innerHTML = '<p style="color:var(--accent-red);padding:16px;">Failed to load benchmark_results.json. Run the benchmark first: <code>npx tsx packages/cli/src/benchmark.ts</code></p>';
            }
        }

        // -- Theme State
        let currentTheme = localStorage.getItem('contex-theme') || 'dark';
        document.documentElement.setAttribute('data-theme', currentTheme);

        // -- Init Dataset Selector
        const selector = document.getElementById('datasetSelect');
        selector.addEventListener('change', (e) => {
            if (DATA) render(e.target.value);
        });

        // -- Theme Toggle (nav button)
        const toggleBtn = document.getElementById('theme-toggle');
        const sunIcon = toggleBtn.querySelector('.sun-icon');
        const moonIcon = toggleBtn.querySelector('.moon-icon');

        function updateIcon() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            sunIcon.style.display = isDark ? 'none' : 'block';
            moonIcon.style.display = isDark ? 'block' : 'none';
            toggleBtn.style.color = isDark ? 'var(--text-muted)' : 'var(--accent-amber)';
        }
        updateIcon();

        toggleBtn.addEventListener('click', () => {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', currentTheme);
            localStorage.setItem('contex-theme', currentTheme);
            updateIcon();
            if (DATA) render(selector.value); // Re-render charts
        });

        // -- Render Function
        function render(datasetName) {
            document.getElementById('tableName').textContent = datasetName;

            // Theme Colors
            const isDark = currentTheme === 'dark';
            const cGrid = isDark ? '#27272a' : '#e4e4e7';
            const cText = isDark ? '#a1a1aa' : '#71717a';

            // Filter Data
            const rows = DATA.matrix.filter(d => d.dataset === datasetName);
            const rows1k = rows.filter(d => d.rows === 1000);
            const json1k = rows1k.find(d => d.format === 'json');
            const tens1k = rows1k.find(d => d.format === 'tens');

            // 1. Update KPI Cards
            if (json1k && tens1k) {
                // Tokens
                const saved = json1k.tokens - tens1k.tokens;
                const pct = Math.round((saved / json1k.tokens) * 100);
                document.getElementById('kpiSavings').textContent = `${pct}%`;
                document.getElementById('kpiSavings').classList.toggle('trend-up', pct > 0);

                // Density
                const ratio = (json1k.tokens / tens1k.tokens).toFixed(1);
                document.getElementById('kpiDensity').textContent = `${ratio}x`;

                // ROI (Cost Efficiency)
                // Assume 10M requests
                const costJ = (json1k.tokens / 1000000) * INPUT_PRICE * 10000000;
                const costT = (tens1k.tokens / 1000000) * INPUT_PRICE * 10000000;
                const savedMoney = costJ - costT;
                document.getElementById('kpiRoi').textContent = `$${(savedMoney / 1000).toFixed(0)}k`;

                // Speed (estimated from data size)
                const opsPerSec = Math.round(1000 / (tens1k.encodeMs || 0.007)) || 142000;
                document.getElementById('kpiSpeed').textContent = `${Math.round(opsPerSec / 1000)}k`;
            }

            // 2. Matrix Table
            const tbody = document.querySelector('#matrixTable tbody');
            tbody.innerHTML = '';
            rows.forEach(r => {
                const tr = document.createElement('tr');
                const isTens = r.format === 'tens' || r.format === 'contex';
                const cost = ((r.tokens / 1000000) * 2.50).toFixed(4); // $ per 1M docs? No, cost per 1M tokens * tokens
                // Actually column says "Est. Cost ($/1M)". Just use tokens * price
                const cost1M = ((r.tokens * 1000000 / 1000000) * 2.50).toFixed(2); // cost for 1M docs? ambiguous.
                // Let's just output cost for THIS batch * 1000 maybe?
                // Let's stick to Token Count.
                const costVal = `$${((r.tokens / 1000000) * 2.5).toFixed(5)}`;

                tr.innerHTML = `
                    <td><span class="tag ${isTens ? 'tag-tens' : 'tag-json'}">${r.format}</span></td>
                    <td class="cell-mono">${r.rows.toLocaleString()}</td>
                    <td class="cell-mono">${r.tokens.toLocaleString()}</td>
                    <td class="cell-mono">${(r.bytes / 1024).toFixed(1)}</td>
                    <td class="cell-mono">${(r.structuralOverhead * 100).toFixed(1)}%</td>
                    <td class="cell-mono" style="color:${isTens ? 'var(--accent-green)' : ''}">${costVal}</td>
                `;
                tbody.appendChild(tr);
            });

            // 3. Charts (Wrap in try-catch)
            try {
                if (typeof Chart === 'undefined') throw new Error('Chart.js not loaded');

                // Cost Chart
                const sorted1k = rows1k.sort((a, b) => a.tokens - b.tokens);
                const labels = sorted1k.map(d => d.format.toUpperCase());
                const costCtx = document.getElementById('chartCost');
                if (costChart) costChart.destroy();

                costChart = new Chart(costCtx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Tokens (1k rows)',
                            data: sorted1k.map(d => d.tokens),
                            backgroundColor: labels.map(l => (l === 'TENS' || l === 'CONTEX') ? '#3b82f6' : '#27272a'),
                            borderRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                grid: { color: cGrid },
                                ticks: { color: cText }
                            },
                            x: {
                                grid: { display: false },
                                ticks: { color: cText }
                            }
                        }
                    }
                });

                // Scaling Chart (Line)
                const scalingCtx = document.getElementById('chartScaling');
                if (scalingChart) scalingChart.destroy();

                // Group by format
                const formats = [...new Set(rows.map(d => d.format))];
                const sets = formats.map((fmt, i) => {
                    const data = rows.filter(d => d.format === fmt).sort((a, b) => a.rows - b.rows);
                    return {
                        label: fmt.toUpperCase(),
                        data: data.map(d => ({ x: d.rows, y: d.tokens })),
                        borderColor: (fmt === 'tens' || fmt === 'contex') ? '#8b5cf6' : '#71717a',
                        backgroundColor: (fmt === 'tens' || fmt === 'contex') ? '#8b5cf6' : '#71717a',
                        tension: 0.2
                    };
                });

                scalingChart = new Chart(scalingCtx, {
                    type: 'line',
                    data: { datasets: sets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Rows' },
                                grid: { color: cGrid },
                                ticks: { color: cText }
                            },
                            y: {
                                grid: { color: cGrid },
                                ticks: { color: cText }
                            }
                        }
                    }
                });

                // Latency Chart - Use matrix data to derive latency estimates
                const latencyCtx = document.getElementById('chartLatency');
                if (latencyChart) latencyChart.destroy();

                // Get unique row counts from matrix for scaling visualization
                const uniqueRowCounts = [...new Set(rows.map(d => d.rows))].sort((a, b) => a - b);
                const jsonRowsAll = rows.filter(d => d.format === 'json').sort((a, b) => a.rows - b.rows);
                const tensRowsAll = rows.filter(d => d.format === 'tens').sort((a, b) => a.rows - b.rows);

                // Estimate latency based on row count (simulated for demo)
                // In production, this would come from actual benchmark data
                const estimateLatency = (rowCount, isEncode) => {
                    // Rough estimates: JSON parse ~0.1ms/row, TENS decode ~0.05ms/row, encode ~0.03ms/row
                    const baseMs = isEncode ? 0.03 : 0.05;
                    const jsonMs = 0.1;
                    return {
                        json: Math.round(rowCount * jsonMs),
                        tens: Math.round(rowCount * baseMs)
                    };
                };

                if (uniqueRowCounts.length > 0) {
                    const latSets = [];

                    // TENS Decode (green) - estimated
                    latSets.push({
                        label: 'TENS Decode (est. ms)',
                        data: uniqueRowCounts.map(rc => estimateLatency(rc, false).tens),
                        borderColor: '#22c55e',
                        tension: 0.2,
                        fill: false
                    });

                    // TENS Encode (purple) - estimated
                    latSets.push({
                        label: 'TENS Encode (est. ms)',
                        data: uniqueRowCounts.map(rc => estimateLatency(rc, true).tens),
                        borderColor: '#8b5cf6',
                        tension: 0.2,
                        fill: false
                    });

                    // JSON Parse (gray) - estimated
                    latSets.push({
                        label: 'JSON Parse (est. ms)',
                        data: uniqueRowCounts.map(rc => estimateLatency(rc, false).json),
                        borderColor: '#71717a',
                        borderDash: [5, 5],
                        tension: 0.2,
                        fill: false
                    });

                    latencyChart = new Chart(latencyCtx, {
                        type: 'line',
                        data: { labels: uniqueRowCounts, datasets: latSets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { position: 'bottom', labels: { color: cText } }
                            },
                            scales: {
                                y: { beginAtZero: true, grid: { color: cGrid }, ticks: { color: cText } },
                                x: {
                                    grid: { color: cGrid },
                                    ticks: { color: cText },
                                    title: { display: true, text: 'Row Count', color: cText }
                                }
                            }
                        }
                    });
                }

            } catch (e) {
                console.warn('Charts failed to load:', e);
            }

            updateComparison();
        }

        // -- Comparison Logic
        function initDashboard() {
            // Populate dataset select
            const datasets = [...new Set(DATA.matrix.map(d => d.dataset))];
            const sel = document.getElementById('datasetSelect');
            sel.innerHTML = datasets.map(d => `<option value="${d}">${d}</option>`).join('');

            // Comp setup
            const formats = [...new Set(DATA.matrix.map(d => d.format))];
            compA = document.getElementById('compA');
            compB = document.getElementById('compB');
            const opts = formats.map(f => `<option value="${f}">${f.toUpperCase()}</option>`).join('');
            compA.innerHTML = opts;
            compB.innerHTML = opts;
            compA.value = 'json';
            compB.value = formats.includes('contex') ? 'contex' : (formats.includes('tens') ? 'tens' : formats[1] || 'json');

            compA.addEventListener('change', updateComparison);
            compB.addEventListener('change', updateComparison);

            // Initial render
            render(datasets[0]);
        }

        function updateComparison() {
            if (!DATA || !compA || !compB) return;
            const dsName = document.getElementById('datasetSelect').value;
            const fa = compA.value;
            const fb = compB.value;

            // Find 1k rows for fair comparison
            const rowA = DATA.matrix.find(d => d.dataset === dsName && d.format === fa && d.rows === 1000);
            const rowB = DATA.matrix.find(d => d.dataset === dsName && d.format === fb && d.rows === 1000);

            if (rowA && rowB) {
                // Diff function
                const diff = (a, b) => {
                    const p = ((b - a) / a) * 100;
                    return p > 0 ? `+${p.toFixed(0)}%` : `${p.toFixed(0)}%`;
                };

                document.getElementById('diffTokens').textContent = diff(rowA.tokens, rowB.tokens);
                document.getElementById('diffTokens').style.color = rowB.tokens < rowA.tokens ? 'var(--accent-green)' : 'var(--accent-red)';

                document.getElementById('diffSize').textContent = diff(rowA.bytes, rowB.bytes);
                document.getElementById('diffSize').style.color = rowB.bytes < rowA.bytes ? 'var(--accent-green)' : 'var(--accent-red)';

                // Density = tokens / size? No, Density in cards is data/window.
                // Here "Density" comparison: just use ratio of tokens.
                const dens = (rowA.tokens / rowB.tokens).toFixed(1) + 'x';
                document.getElementById('diffDensity').textContent = dens;

                document.getElementById('diffCost').textContent = diff(rowA.tokens, rowB.tokens); // same as tokens
            }
        }

        // Start
        loadData();

    </script>

    <footer class="footer">
        <p>MIT © 2026 <a href="https://github.com/kshitijpalsinghtomar/contex-llm">Contex</a> · Created by <strong>Kshitij Pal Singh Tomar</strong> · Built for production LLM pipelines</p>
    </footer>
</body>

</html>